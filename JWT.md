이번 4학년 1학기 과목인 미디어프로젝트를 수강하면서 프로젝트를 진행하는데 저는 바로 여기서 백엔드 부분과 NLP 뉴스 감정 분석을 맡게 되었습니다.(왜 하나 하나 씩 더 늘어나는 거죠 ㅠㅠ)

<img src="https://blog.kakaocdn.net/dn/F5UdR/btq38fzopmb/FP1b5BVrJSfY6O8Fw7wBiK/img.jpg" alt="img" style="zoom:200%;" />



그래서 우선 로그인 및 회원가입에 대한 자료를 찾아보던중 핵심 키워드 쿠키, 세션, 그리고 \*\***JWT**\*\* 라는 거에 대해서 알게 되었습니다!

이번 포스팅은 JWT에 대한 설명 포스팅을 진행하겠습니다!

## JWT

JSON Web Token의 약자로 두 개체에서 JSON 형태를 사용하므로 쉽게 전달될 수 있으면서 많은 것을 포함한 방식으로 안전하게 전달 되는 방식을 의미합니다. 안전 이란 키워드가 들어간 만큼 주로 회원 인증과
두 개체 사이에서 정보 전달을 할 때 사용됩니다.

- 많은 것을 포함하였다?
- JWT는 필요한 모든정보를 자체적으로 지니고 있기 때문에 JWT 시스템에서 발급된 토큰은 토큰에 대한 기본정보, 전달 할 정보, 토큰이 검증되었다는것을 증명해주는 서명도 포함하고 있습니다.

- 쉽게 전달 될 수 있다?
- 웹서버의 경우 HTTP 헤더에 넣어서 전돨 또는 URL 파라미터로 전달 될 수 있습니다.

그렇다면 저는 JWT를 어떻게 사용할까요?

\- 회원인증을 위해서 사용합니다. 사실 이는 JWT를 사용하는 가장 흔한 시나리오 인데요. 유저가 로그인을 하면, \*\***서버는 유저의 정보에 기반한 토큰을 발급**\*\*하여 유저에게 전달해줍니다.

그 후, 유저가 서버에 인증을 할 때 마다 JWT를 포함하여 전달합니다. 서버가 클라이언트에게서 요청을 받을때 마다, 해당 토큰이 유효하고 인증되었는지 검증을 하고, 유저가 요청한 작업에 권한이 있는지 확인하여
작업을 처리합니다.

서버측에서는 유저의 세션을 유지할 필요가 없습니다. 즉, 유저가 로그인 되어있는지 그렇지 않은지 신경 쓸 필요가 없고, 유저가 요청했을때 토큰만 확인하면 되니, 세션 관리가 필요 없어서 서버 자원을 많이 아낄 수
있습니다!

__잠깐!__ 여기서 __토큰 기반 인증방식__ 과 __세션 인증 방식__ 을 비교해보면 토큰 기반 인증 방식은 stateless 한 성질을 가지고 있고 세션은 stateful (원래 웹 자체는
stateless입니다.) 하는척 하는거라고 생각해주시면 됩니다.

\- 저는 이렇게 사용하지는 않았지만 JWT는 정보교류에 대해서도 안정성있게 정보를 교환하기 좋은 방법이라고 합니다. 바로 정보가 sign 되어있기 때문에 정보를 보낸이가 바뀌지는 않았는지, 또 정보가 도중에
조작되지는 않았는지 검증 할 수 있기 때문이라고 합니다.

백문이 불여일견이라고 JWT의 생김새를 한변 살펴 볼까요?

![img](https://blog.kakaocdn.net/dn/mnruK/btq38eUPKWs/tMGOK0qFvFqM93fYp69Az0/img.png)

JWT는 .(온점) 을 구분자로 3가지 문자열로 되어있습니다.

### Header

헤더는 두가지 정보를 지니고 있습니다.

typ: 토큰의 타입을 지정합니다. 저는 JWT를 이용하고 있으니까 이 부분은 JWT가 되겠죠

alg: 해싱 알고리즘을 지정합니다. 해싱 알고리즘은 보통 HMAC SHA256, RSA가 사용됩니다. 여기서 명시해준 알고리즘은, 토큰을 검증할 때 사용되는 signature 부분에서 사용됩니다.

예시

`{`

`"typ": "JWT",`

`"alg": "HS256"`

`}`

이걸 JSON 으로 짜게 된다면

```javascript
const header = {
  "typ" : "JWT",
  "alg" : "HS256"
}

const encodedHeader = new Buffer(JSON.stringify(header)).toString('base64').replace('=', '');
console.log('header':encodedHeader)

/*Result
header: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
*/

참고로 JSON 형태의 객체가 base 64로 인코딩 되는 과젱에서 공백, '/', 엔터 들이 사라진다. 따라서, 다음과 같은 문자열을 인코딩하게 된다.
{"alg":"HS256","typ":"JWT"}
```

종종 해당 작업을 진행 할 때 BASE64를 많이 보게 되는데 이는 인코딩의 방법중 하나로서 Binary Data를 Text로 변경하는 Encoding 입니다. 이를 쓰는 이유는 HTML 또는 Email과 같이
문자를 위한 Media에 Binary Data를 포함해야 될 필요가 있을때, 포함된 Binary Data가 시스템 독립적으로 동일하게 전송 또는 저장 되는걸 보장하기 위해 사용한다고 합니다.(자세한
\[[내용](https://effectivesquid.tistory.com/entry/Base64-%EC%9D%B8%EC%BD%94%EB%94%A9%EC%9D%B4%EB%9E%80)\]([https://effectivesquid.tistory.com/entry/Base64-%EC%9D%B8%EC%BD%94%EB%94%A9%EC%9D%B4%EB%9E%80](https://effectivesquid.tistory.com/entry/Base64-%EC%9D%B8%EC%BD%94%EB%94%A9%EC%9D%B4%EB%9E%80))은
여기서 확인하실 수 있습니다. )

### Payload

페이로드 부분에는 토큰에 담을 정보가 들어가 있습니다. 여기에 담는 정보의 한 '조각'을 클레임이라고 부르고, 이것은 name/value의 한 쌍으로 이뤄져있습니다. 토큰에는 여러개의 클레임 들을 넣을 수 있습니다.

클레임의 종류는 크게 3 분류로 나눠 볼 수 있습니다.

* 등록된(registered) 클레임,
* 공개(public) 클레임,
* 비공개(private) 클레임

그럼 순서대로 알아보겠습니다.

#### 등록된 (registered) 클레임

서비스에서 필요한 정보들이 아닌, 토큰에 대한 정보를 담기위하여 이름이 이미 정해진 클레임들입니다. 이것의 사용은 모두 선택적이며, 등록된 클레임으로는

* `iss` : 토큰 발급자
* `sub` : 토큰 제목
* `aud` : 토큰 대상자
* `exp`: 토큰의 만료 시간, 시간은 NumericDate 형식으로 되어있어야 합니다. 또한 현재 시간보다 이후로 설정되어 있어야 합니다.
* `nbf`: Not before 를 의미하며, 토큰의 활성 날짜와 비슷한 개념입니다. 여기에도 exp에서와의 동일한 형식으로 NumericDate 형식으로 날짜를 지정해야하고, 이 날짜가 지나기 전까지는 토큰이
  처리되지 않습니다.
* `iat`: 토큰이 발급된 시간이며 이 값을 사용하여 토큰의 age가 얼마나 되었는지 판단할 수 있습니다.
* `jti`: JWT의 고유 식별자로서, 주로 중복적인 처리를 방지하기 위하여 사용됩니다. 일회용 토큰에 사용하면 유용합니다.

#### 공개 (public) 클레임

공개 클레임들은 충돌이 방지된 이름을 갖고 있어야 합니다. 충돌을 방지하기 위해선 클레임 이름을 URI 형식으로 짓습니다.

```json
{
	ㄴ
}
```

