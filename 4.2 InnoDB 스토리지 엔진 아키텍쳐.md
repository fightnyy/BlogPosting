# 4.2 InnoDB 스토리지 엔진 아키텍쳐

* `innoDB` 는 레코드 기반 잠금을 제공한다.
  * 높은 동시성 처리가 가능하다.
  * 안정적이고 성능이 뛰어나다.



## 4.2.1 프라이머리 키에 의한 클러스터링

* `InnoDB` 의 모든 테이블은 기본적으로 PK 를 기준으로 클러스터링돼 저장된다.
  * PK 값의 순서대로 디스크에 저장된다.
  * 모든 세컨더리 인덱스는 레코드의 주소 대신 PK 값을 논리적인 주소로 사용한다. 
* PK 가 클러스터링 인덱스기 때문에 PK 를 이용한 range scan은 상당히 빨리 처리될 수 있다.
* 따라서 쿼리의 실행계획에서PK 는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.
* `MyISAM` 스토리지 엔진은 클러스터링 키를 지원하지 않는다.
  * 그래서 `MyISAM` 테이블에서는PK와 세컨더리 인덱스는 구조적으로 아무런 차이가 없다.
* `MyISAM` 테이블의 PK값을 포함한 모든 인덱스는 물리적인 레코드의 주소값을 가진다.

## 4.2.2 외래키 지원

* 외래키는 `InnoDB`  스토리지 엔진 레벨에서 지원하는 기능이다.

  * `MyISAM` 과 `MEMORY` 테이블 에서는 사용할 수 없다.

* 서비스 레벨에서는 생성하지 않는 경우도 있는데 개발 환경 DB에는 좋은 가이드 역할을 해줄 수 있기 때문에 생성하는 것이 좋다.

* 외래키가 복잡하게 얽힌 경우엔 수동으로 데이터를 적재하거나 스키마 변경등이 실패하는 경우가 종종 일어난다.

  * 이런 경우 `foreign_key_checks` 시스템 변수를 `OFF` 로 놓으면 외래키 관계에 대한 체크작업을 잠시 중단할 수 있다. 

  * 중단하고 난뒤 작업을 하고 다시 `foreign_key_checks` 를 키려면 외래키 제약 조건에 맞는 레코드로 올바르게 세팅을 한뒤 켜야한다.

  * `foreign_key_checks` 를 끄면 `ON DELETE CASCADE 와 UPDATE CASCADE 옵션` 도 무시하게 된다.

  * `foreign_key_checks` 시스템 변수는 `GLOBAL` , `SESSION` 모두 설정 가능하다. 

  * 작업이 완료 되면 반드시 현재 세션을 종료하거나 현재 세션의 외래키 체크를 다시 활성화해야 한다.

    ```mysql
    # 기본적으로 SESSION 키워드를 입력하지 않으면 자동으로 세션 설정만 변경한다. 아래의 두 명령어는 같은 의미를 가지고 있다.
    
    SET foreign_key_checks=OFF;
    SET SESSION foreign_key_checks=OFF;
    ```

    

## 4.2.3 MVCC(Multi Version Concurrency Control)

* 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
* `MVCC` 의 목적은 잠금을 사용하지 않는 일관된 읽기 제공
  * `InnoDB` 는 언두로그를 이용하여 해당 기능 구현
* `Multi Version` 이란 하나의 레코드에 대해 여러개의 버전이 동시에 관리 된다는 의미
  * 만약 `update` 쿼리가 나갈때 새로 변경된 내용은 `InnoDB 버퍼풀`에 저장되어있고 그 전에 내용은 `undo 로그` 에 저장되어있다.
  * 이때 `commit` 을 하면 데이터 파일이 있는 디스크에 `InnoDB 버퍼풀`에 있는 내용이 옮겨 질 것이고 `rollback` 을 하면 `undo 로그` 에 있는 내용이 `InnoDB 버퍼풀`로 이동하고 `undo 로그`를 삭제한다. 
  * `commit` 은 `undo 로그` 를 바로 삭제한 것지 않는다. 
    * `undo 로그` 를 더이상 필요로 하는 트랜잭션이 없을 때 삭제된다.

## 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

* `InnoDB` 스토리지 엔진은 `MVCC` 기술을 이용해 `Lock` 을 걸지 않고 작업을 수행한다.
* `Serializable` 이 아닌 그보다 낮은 격리 수준을 사용한다면 `Insert` 와 연결되지 않은 순수한 `Select` 작업은 `Lock` 을 대기 하지 않고 즉시 실행된다. 
  * 바로 `undo 로그`를 사용하면 항상 일관되게 읽을 수 있기 때문이다. 
* 오랜 시간동안 트랜잭션을 활성상태로 열어놓으면 `undo 로그`를 삭제하지 못하고 계속 유지해야 하기때문에 종종 서버가 느려지는 문제가 발생하기도 한다.
  * 따라서 트랜잭션이 시작되었다면 가능한 빨리 `Rollback` 이나 `Commit` 을 수행하는것이 좋다.



## 4.2.5 자동 데드락 감지

* `InnoDB` 스토리지 엔진은 내부적으로 `Lock` 이 교착상태에 빠지지 않았는지 체크하기 위해 `Lock` 대기 목록을 그래프(Wait-for List) 형태로 관리한다.
* `InnoDB ` 스토리지 엔진은 데드락 감지 스레드를 가지고 있어 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아 그중 하나를 종료 시킨다.
  * 적은 `undo 로그`  를 가진 트랜잭션을 종료시킨다.
* `InnoDB` 스토리지 엔진은 상위 레이어인 `MySQL` 엔진에서 관리되는 테이블 잠금(`LOCK TABLE 명령으로 잠긴 테이블`)은 볼 수 없어 데드락 감지가 불확실 할 수 있다.
  * 이때, `innodb_table_locks` 변수를 활성화 하면 `InnoDB` 스토리지 엔진 내부의 레코드 `Lock` 과 테이블 레벨의 `Lock` 까지 모두 감지할 수 있다. 
  * 따라서 `innodb_table_locks` 변수를 활성화 시키자
* 동시 처리 스레드가 매우 많거나 각 트랜잭션이 가진 `Lock` 의 개수가 많아지면 데드락 감지 스레드는 매우 느려진다.
  * 데드락 감지 스레드는 `Lock` 목록을 검사해야 하기 때문에 `Lock`목록이 저장된 리스트에 새로운 잠금을 걸고 데드락 스레드를 찾는다.
* 데드락 감지 스레드가 느려지면 서비스 쿼리를 처리하는 스레드는 작업을 진행 못하고 대기하여 서비스에 악영향을 미친다.
* 이런 문제를 해결하기 위해 `innodb-deadlock_detect` 시스템 변수를 `OFF` 로 설정하게 되면 데드락 감지 스레드가 더는 작동하지 않는다.
* 대신 `innodb_lock_wait_timeout` 시스템 변수를 활성화 시켜 데드락 상황이 감지되었을 때 일정시간이 지나면 요청을 실패하고 에러메시지를 반환할 수 있도록 하자.
  * 초단위로 설정할 수 있고 기본값이 50초보다 훨씬 낮은 시간으로 변경해서 사용할 것을 권장한다.

## 4.2.6 자동화된 장애 복구

- `InnoDB` 스토리지 엔진은 매우 견고해서 왠만해선 데이터파일이 손상되거나 서버가 시작되지 못하는 경우가 발생하지 않는다.
- 하지만 디스크나 하드웨어 이슈로 문제가 생기는 경우가 있는데 이땐 `MySQL` 설정 파일의 `innodb_force_recovery` 시스템 변수를 사용해 해결해야 한다.
  - 참고로 `MySQL` 은 기본적으로 서버를 맨처음 시작할때 자동 복구를 수행한다. 하지만 위의 케이스는 자동 복구가 안되고 `MySQL`서버가 죽는경우이다.
- `innodb_force_recovery` 값으로 설정할 수 있는 값은 1~6 까지이다.
  - 높으면 높을 수록 데이터 손실가능성이 커진다.
  - 이땐 `SELECT` 를 제외한 어떤 쿼리도 사용할 수 없다.



## 참고

* 레코드 

  *  여러 가지 데이터 타입을 가질 수 있는 복합형 구조의 데이터 타입이며, **하나의 행(Row)**에 대응한다. 

* COMMIT 

  *  저장되지 않은 모든 데이터를 데이터베이스에 저장하고 현재의 트랜잭션을 종료하라는 명령

* Dirty Read 

  * 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데 다른 트랜잭션에서 볼 수 있게 되는 현상

* 격리수준

  * 서로 다른 트랜잭션들이 서로 어디 까지 격리 되어야 하는지 정의한것

  * 총 4가지로 나뉨

    * `Read UnCommited`
    * `Read Commited`
    * `Repeateable Read`
    * `Serializable`

  * 위로 갈 수록 격리 수준은 낮아지고, 격리 수준이 낮아질 수록 동시성은 높아진다

  * `Read Uncommited` 는 일반적인 DB에서 잘 사용안되고 `Serializable` 은 동시성이 중요한 DB에서 거의 사용안됨(MySQL에서는 주로 Repeatable Read 가 사용됨, 또한 이것이 default 값임) 

    |                  | Dirty Read | Non-Repeateable Read |          Phantom Read          |
    | :--------------: | :--------: | :------------------: | :----------------------------: |
    | Read UnCommited  |     O      |          O           |               O                |
    |  Read Commited   |     X      |          O           |               O                |
    | Repeateable Read |     X      |          X           | O (단, InnoDB는 발생하지 않음) |
    |   Serializable   |     X      |          X           |               X                |

    참고 : https://transferhwang.tistory.com/513