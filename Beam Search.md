# Beam Search

![image](https://user-images.githubusercontent.com/55227984/126916561-a3b754f6-d785-4e0f-bf45-984aa38988df.png)

> Beam Search 는 탐욕 방법과 함께 가장 많이 사용되는 휴리스틱 방법이다. 각각의 타임 스텝에서 가능도가 가장 높은 하나의 토큰을 선택하는 __Greedy Search__ 와는 달리 __Beam Search__ 는 각 스텝에서 탐색의 영역을 K개의 가장 가능도가 높은 토큰들을 유지하며 다음 단계를 탐색하는 것을 의미한다. 이때 __K__ 는 사용자가 지정하는 hyper-parameter이다.

# Beam Search Algorithm

> parameter K가 주어질 때 예측된 확률 분포의 시퀀스에 대해 beam search 를 진행하는 과정은 다음과 같다.
>
> 1. 각 스텝에서 각각의 후보 시퀀스를 모두 가능한 다음 step으로 확장한다.
     >
     >    ex. 해당 스텝에서 <BOS> 라는 토큰이 나왔으면 그 다음 step은 뭐가 몇 %의 확률로 나오는지 체크하는 것을 의미한다.
>
> 2. 확장된 후보 스텝에 대해 점수를 계산하는데. 점수는 모든 확률 값을 곱하여 얻는다.
>
> 3. 가능도가 높은 K개의 시퀀스만 남기고, 나머지 후보들은 제거한다.
>
> 4. 시퀀스가 끝날 때까지 위의 과정을 반복한다.
>
> > 여기서 4번째 단계의 시퀀스의 끝을 판별할 때 해당 기준을 아래와 같이 둘 수 있다.
> >
> > * <eos> 토큰이 등장함
> > * 설정한 최대 길이에 도달
> > * threshold likehood 밑으로 가능도가 낮아짐

__그림에서 보면 확률값이 negative이면서 1.0 보다 큰것을 볼 수 있다.__

> 이는 각 __타임 스텝에서의 확률 값은 V 차원 단어 사전에 대한 softmax 값으로 매우 작은 값을 가질 수 있다.__ 따라서 디코딩 스텝이 진행됨에 따라 이 값들을 계속 곱하게 되면 부동소수점 연산에서 underflow가 나타날 수 있기 때문에, 확률 값에 자연로그(log) 변환을 취해 사용한다. 또한 최소화를 통해 해를 찾기 위해 부호 변환을 적용한다. 