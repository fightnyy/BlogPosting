# Index

* `RDMBS` 에서 검색 속도를 높이기 위한 기술
* `TABLE` 의 컬럼을 색인화(따로 파일로 저장) 하여 **검색시 해당 TABLE의 레코드를 Full Scan 하는게 아니라 색인화 되어있는 INDEX 파일을 검색하여 검색속도를 빠르게** 한다.
* RDBMS에서 사용하는 INDEX는 B-Tree에서 파생된 **B+ Tree** 를 사용하여 색인화 한다.
* 주목적은 **SELECT 쿼리의 검색 속도를 빠르게 한다** 이다.
  * **DELETE, INSERT, UPDATE** 쿼리는 해당사항이 없고 INDEX 사용시 오히려 느려진다.
* SQL 서버에서는 데이터의 레코드가 **아무런 순서 없이 저장** 된다.
* 이때 저장되는 영역을 **Heap** 이라고 부른다.
* **Heap** 에서는 인덱스가 없는 테이블의 데이터를 찾을 때 전체 데이터의 페이지의 처음 레코드부터 끝 페이지의 마지막 레코드까지 모두 조회하여 검색조건을 비교한다.
  * 이런방법을 `테이블 스캔` 또는 `풀 스캔` 이라고 한다.
  * 이때 데이터의 양이 많은 테이블의 경우 풀 스캔을 하면 처리 성능이 떨어진다.



## Index 사용 이유

* `Where` 구문과 일치하는 열을 **빨리 찾기 위해**
* 특정 열을 고려 대상에서 **빨리 없애 버리기 위해**
* **조인을 실행** 할 때 **다른 테이블에서 열을 추출** 하기 위해



## Index 생성

* 하나의 열에 `Index` 를 생성 할 수 있고, 여러 열에 하나의 `Index` 를 생성 할 수도 있다.
* 테이블 생성시 하나의 열에 `Primary Key` 를 지정하면 자동으로 `Clustered Index` 가 생성된다.
* 인덱스를 만들기 위해선 **`Primary Key` 혹은 `Unique`  를 만들어야 한다.**



참고로 `Index` 에는 `Clustred Index` 와 `Non-Clustered Index` 두 종류가 존재한다.

## Clustered Index

* `Clustered Index` 를 책으로 비유하자면 페이지를 알고 있어서 바로 해당 페이지를 펼치는 것과 같다.
* `Clustered Index` 는 테이블의 데이터를 지정된 컬럼에 대해 물리적으로 데이터를 재배열 한다.
* 데이터가 테이블에 삽입되는 순서에 상관없이 `Index` 로 생성되어 있는 컬럼을 기준으로 정렬되어 삽입된다.(데이터 삽입, 수정, 삭제시 테이블의 데이터를 정렬)
* `Index Page` 를 `키값` 과 `데이터 페이지 번호` 로 구성하고, 검색하고자 하는 데이터의 `키 값` 으로 `페이지 번호`를 검색하여 데이터를 찾는다.
* `Clustered Index` 는 테이블 당 한개씩만 존재 가능하다.
* 그래서 테이블에서 Index를 걸면 가장 효율적인 거 같은 컬럼을 `Clustered Index` 로 지정한다.

 

## B-Tree 알고리즘 사용 이유

* B+ Tree
  * 컬럼의 값을 변형하지 않고(값의 앞부분만 잘라서 관리), **원래의 값을 이용해 인덱싱** 하는 알고리즘이다.
* Hash
  * 컬럼의 값으로 해시 값을 계산





